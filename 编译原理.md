 LR（0）

SLR

LR(1)

LALR

### chapter 2 exercise p232

![image-20240421235036823](./assets/image-20240421235036823-1713972744412-1.png)

Textbook p206 exercise 4.2.2 d) 

(1)   Give a LM derivation, a RM derivation and a parser tree for the string; Justify whether the grammar is ambiguous or not

(2)   left factor and eliminate left recursion the grammar

(3)   Justify whether the rewritten grammar is LL(1) grammar or not.

(4)   construct LL(1) parsing table and analyze the string.



Every construct that can be described by a regular expression can be described by a grammar,but not vice-versa.Alternatively,every regular language is a context-free language,but not vice-versa.上下文无关文法>正则表达式

### Ambiguity



a grammar that produces more than one parse tree for some sentence is said to be ambiguous.Put another way,an ambiguous grammar is one that produces more than one leftmost derivation or more than one rightmost derivation for the same sentence

有多个解析树，或者有多于一个最左推导或者最有推导，即这个语法有歧义（如果没有歧义，左右推导得出的语法树相同，且验证需要多个句子列举测试）

### 句子和句型

#### 句子（Sentence）

句子是特殊类型的句型，它不包含任何非终结符，只由终结符组成。句子是文法生成的最终产品，

#### 句型（Sentential Form）

句型是指从文法的起始符号（通常是非终结符）出发，通过一系列的产生式规则替换（应用文法中的规则），得到的一个由终结符和/或非终结符组成的字符串。句型代表了生成某个特定句子的过程中的一个中间状态，这个状态可能还包含一些非终结符（即还可以继续进行产生式规则的替换）。

句子只能由终结符，句型还可以有非终结符（可以是起始符号），句子为特殊的句型

### Elimination of Left Recursion

general case：

First,group the productions as

![image-20240422204256911](./assets/image-20240422204256911-1713972744412-2.png)

where no βi begins with an A.Then,replace the A-productions by

![image-20240422204555296](./assets/image-20240422204555296-1713972744413-3.png)

但是上述算法解决不了涉及>=2个左递归的情况 it does not eliminate left recursion involving derivations of two or more steps：

for example：    ![image-20240422205149537](./assets/image-20240422205149537-1713972744413-4.png)

![image-20240422205203735](./assets/image-20240422205203735-1713972744413-5.png)

### Left Factoring

When the choice between two alternative A-productions is not clear,we may be able to rewrite the productions to defer the decision until enough of the input has  been seen that we can make the right choice.![image-20240422202825002](./assets/image-20240422202825002-1713972744413-6.png)

![image-20240422202838630](./assets/image-20240422202838630-1713972744413-7.png)

### Recursive-descent

General recursive-descent may require backtracking;that is,it may require repeated scans over the input.一般的递归下降需要回溯，即重复扫描输入

#### LL（1）grammer

###### first set

![image-20240422212811433](./assets/image-20240422212811433-1713972744413-8.png)

如果ε在FIRST(α)中，这表明存在至少一种从α开始的推导，使得α最终推导为一个空字符串。

###### follow set

![image-20240422212948228](./assets/image-20240422212948228-1713972744413-9.png)

![image-20240422235906689](./assets/image-20240422235906689-1713972744413-10.png)

这里切记左边是右边的子集

###### kookhead sets

![image-20240422213227334](./assets/image-20240422213227334-1713972744413-11.png)

Predictive parsers,that is,**recursive-descent** parsers needing no backtracking, can be constructed for a class of grammars called **LL(1)**.

- The first "L"in LL(1)stands for scanning the input from left to right从左到右扫描输入
- the second "L"for producinga leftmost derivation,最左推导的产生式
-  the "1"for using one input symbol of lookahead at each step to make parsing action decisions.

老师ppt对**LL(1)前提**的简化版，易于理解
A grammar is LL(1)grammar if the following conditions are satisfied:
![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

##### LL(1)文法的识别/判断-4部

1. 求出可空非终止符的集合（nullable nonterminal）

   

2. ![](./assets/image-20240422222743225-1713972744413-13.png)

3. ![image-20240422214233812](./assets/image-20240422214233812-1713972744413-15.png)

4. ![image-20240422214254730](./assets/image-20240422214254730-1713972744413-14.png)

example：![image-20240422225008300](./assets/image-20240422225008300-1713972744413-16.png)

只需要知道每个非终结符的first、follow的set以及可空非终结符（求first要用），其余的可以借助规则迅速推导，结合以下条件判断即可

![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

一定不是LL(1)的情况：有左递归或者左公因子之一，一定不是LL(1）;但是二者皆没有不能保证一定是LL（1）文法

### construction of Predictive parsing table 

![image-20240423010552238](./assets/image-20240423010552238-1713972744413-18.png)

### Model of a table-driven predictive parser

![image-20240423013933306](./assets/image-20240423013933306-1713972744413-17.png)

栈中最开始存放start symbol，input buffer存放输入，$代表栈底或者输入结束

METHOD:Initially,the parser is in a configuration with **w$**in the input buffer and the start symbol S of G on top of the stack,above $The program in Fig.4.20 uses the predictive parsing table M to produce a predictive parse for the input.

![image-20240423014229705](./assets/image-20240423014229705-1713972744414-19.png)

注意产生式右部压栈的时候，最开始的在栈顶（即Y1在栈顶），每次循环判断栈顶是否与输入buffer中当前所指的终结符匹配，匹配则弹栈，输入后移，栈中存放待处理的元素

## regx->DFA（汤姆逊构造法-子集构造法-最小化算法）

### 步骤1: 汤姆逊构造法构建NFA

对于正则表达式 `a|ε`，我们分别为 `a` 和 `ε` 构建NFA，然后合并。

1. **构造 `a` 的NFA**：
   - 创建两个状态：`q0` 和 `q1`。
   - 添加从 `q0` 到 `q1` 的转移，标记为 `a`。

   图示如下：
   ```
   q0 --a--> q1
   ```

2. **构造 `ε` 的NFA**：
   - 创建两个状态 `q2` 和 `q3`。
   - 添加从 `q2` 到 `q3` 的ε转移。

   图示如下：
   ```
   q2 --ε--> q3
   ```

3. **合并 `a` 和 `ε` 的NFA**：
   - 创建一个新的起始状态 `q_start` 和一个新的接受状态 `q_accept`。
   - 添加从 `q_start` 到 `q0` 和 `q2` 的ε转移。
   - 添加从 `q1` 和 `q3` 到 `q_accept` 的ε转移。

   最终的NFA图示如下：
   ```
   q_start --ε--> q0 --a--> q1 --ε--> q_accept
             \                          ^
              \--ε--> q2 --ε--> q3 --ε-/
   ```

### 步骤2: 子集构造法将NFA转换为DFA

现在我们使用子集构造法将上述NFA转换为DFA。

1. **初始状态**：
   - DFA的起始状态是NFA起始状态通过ε移动可达的所有状态的集合：`{q_start, q0, q2, q3, q_accept}`。

2. **计算转移**：
   - 从状态 `{q_start, q0, q2, q3, q_accept}` 输入 `a`：
     - 只有 `q0` 有标记为 `a` 的出边，它通向 `q1`。从 `q1` 可以通过ε到达 `q_accept`。因此，新的状态是 `{q1, q_accept}`。

3. **终止状态**：
   - 任何包含 `q_accept` 的状态都是DFA的接受状态。

   最终DFA的状态和转移如下：
   - 状态 `{q_start, q0, q2, q3, q_accept}`，标记为接受状态。
   - 状态 `{q1, q_accept}`，标记为接受状态。
   - 转移：`{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}`。

DFA 图示：
```
{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}
{q_start, q0, q2, q3, q_accept} ------------------- (为接受状态)
{q1, q_accept} ------------------- (为接受状态)
```

通过这一过程，我们已经从正则表达式 `a|ε` 构造出了DFA，该DFA有效地识别由 `a` 或空串 `ε` 组成的语言。

继续从上述的DFA最小化过程，我们将使用常见的状态最小化技术，通常包括初始划分（区分接受状态和非接受状态）并迭代地细化状态分区直到达到稳定状态。这一过程旨在合并所有行为相同的状态，从而简化DFA。

### 步骤3: 状态最小化

由于在构造的DFA中，所有状态都是接受状态，这通常意味着每个状态在语言接受方面的行为都相同。但是，我们需要仔细检查这些状态对于所有输入符号的反应是否确实相同。

1. **初始状态划分**：
   - 由于 `{q_start, q0, q2, q3, q_accept}` 和 `{q1, q_accept}` 都是接受状态，我们可以开始考虑它们是否能够被进一步合并。这取决于它们对输入符号 `a` 的反应是否相同。

2. **检查转移**：
   - 从 `{q_start, q0, q2, q3, q_accept}` 输入 `a`，结果状态是 `{q1, q_accept}`。
   - 从 `{q1, q_accept}` 输入 `a` 时，由于没有定义从 `q1` 出发的 `a` 转移，这可以被视为一个死状态或沉默状态。这意味着这两个状态集在响应 `a` 时行为不同。

3. **无法进一步合并**：
   - 因为在接受字符 `a` 时，两个状态集的行为不同（一个转移到另一个，另一个无响应），我们无法将这两个状态合并。

4. **最终最小化DFA**：
   - 最小化后的DFA与前面生成的DFA相同，因为没有进一步的合并机会。

#### 最小化DFA的示意图和描述：
```
{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}
{q_start, q0, q2, q3, q_accept} ------------------- (为接受状态)
{q1, q_accept} ------------------- (为接受状态)
```

- **状态**：
  - `{q_start, q0, q2, q3, q_accept}`：在没有输入时即可接受输入串（因为包含起始状态和接受状态）。
  - `{q1, q_accept}`：仅在接受字符 `a` 后接受输入串。

# chapter5 Syntax-Directed  Translation p328


 LR（0）

SLR

LR(1)

LALR

### chapter 2 exercise p232

![image-20240421235036823](./assets/image-20240421235036823-1713972744412-1.png)

Textbook p206 exercise 4.2.2 d) 

(1)   Give a LM derivation, a RM derivation and a parser tree for the string; Justify whether the grammar is ambiguous or not

(2)   left factor and eliminate left recursion the grammar

(3)   Justify whether the rewritten grammar is LL(1) grammar or not.

(4)   construct LL(1) parsing table and analyze the string.



Every construct that can be described by a regular expression can be described by a grammar,but not vice-versa.Alternatively,every regular language is a context-free language,but not vice-versa.上下文无关文法>正则表达式

### Ambiguity



a grammar that produces more than one parse tree for some sentence is said to be ambiguous.Put another way,an ambiguous grammar is one that produces more than one leftmost derivation or more than one rightmost derivation for the same sentence

有多个解析树，或者有多于一个最左推导或者最有推导，即这个语法有歧义（如果没有歧义，左右推导得出的语法树相同，且验证需要多个句子列举测试）

### 句子和句型

#### 句子（Sentence）

句子是特殊类型的句型，它不包含任何非终结符，只由终结符组成。句子是文法生成的最终产品，

#### 句型（Sentential Form）

句型是指从文法的起始符号（通常是非终结符）出发，通过一系列的产生式规则替换（应用文法中的规则），得到的一个由终结符和/或非终结符组成的字符串。句型代表了生成某个特定句子的过程中的一个中间状态，这个状态可能还包含一些非终结符（即还可以继续进行产生式规则的替换）。

句子只能由终结符，句型还可以有非终结符（可以是起始符号），句子为特殊的句型

### Elimination of Left Recursion

general case：

First,group the productions as

![image-20240422204256911](./assets/image-20240422204256911-1713972744412-2.png)

where no βi begins with an A.Then,replace the A-productions by

![image-20240422204555296](./assets/image-20240422204555296-1713972744413-3.png)

但是上述算法解决不了涉及>=2个左递归的情况 it does not eliminate left recursion involving derivations of two or more steps：

for example：    ![image-20240422205149537](./assets/image-20240422205149537-1713972744413-4.png)

![image-20240422205203735](./assets/image-20240422205203735-1713972744413-5.png)

### Left Factoring

When the choice between two alternative A-productions is not clear,we may be able to rewrite the productions to defer the decision until enough of the input has  been seen that we can make the right choice.![image-20240422202825002](./assets/image-20240422202825002-1713972744413-6.png)

![image-20240422202838630](./assets/image-20240422202838630-1713972744413-7.png)

### Recursive-descent

General recursive-descent may require backtracking;that is,it may require repeated scans over the input.一般的递归下降需要回溯，即重复扫描输入

#### LL（1）grammer

###### first set

![image-20240422212811433](./assets/image-20240422212811433-1713972744413-8.png)

如果ε在FIRST(α)中，这表明存在至少一种从α开始的推导，使得α最终推导为一个空字符串。

###### follow set

![image-20240422212948228](./assets/image-20240422212948228-1713972744413-9.png)

![image-20240422235906689](./assets/image-20240422235906689-1713972744413-10.png)

这里切记左边是右边的子集

###### kookhead sets

![image-20240422213227334](./assets/image-20240422213227334-1713972744413-11.png)

Predictive parsers,that is,**recursive-descent** parsers needing no backtracking, can be constructed for a class of grammars called **LL(1)**.

- The first "L"in LL(1)stands for scanning the input from left to right从左到右扫描输入
- the second "L"for producinga leftmost derivation,最左推导的产生式
-  the "1"for using one input symbol of lookahead at each step to make parsing action decisions.

老师ppt对**LL(1)前提**的简化版，易于理解
A grammar is LL(1)grammar if the following conditions are satisfied:
![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

##### LL(1)文法的识别/判断-4部

1. 求出可空非终止符的集合（nullable nonterminal）

   

2. ![](./assets/image-20240422222743225-1713972744413-13.png)

3. ![image-20240422214233812](./assets/image-20240422214233812-1713972744413-15.png)

4. ![image-20240422214254730](./assets/image-20240422214254730-1713972744413-14.png)

example：![image-20240422225008300](./assets/image-20240422225008300-1713972744413-16.png)

只需要知道每个非终结符的first、follow的set以及可空非终结符（求first要用），其余的可以借助规则迅速推导，结合以下条件判断即可

![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

一定不是LL(1)的情况：有左递归或者左公因子之一，一定不是LL(1）;但是二者皆没有不能保证一定是LL（1）文法

### construction of Predictive parsing table 

![image-20240423010552238](./assets/image-20240423010552238-1713972744413-18.png)

### Model of a table-driven predictive parser

![image-20240423013933306](./assets/image-20240423013933306-1713972744413-17.png)

栈中最开始存放start symbol，input buffer存放输入，$代表栈底或者输入结束

METHOD:Initially,the parser is in a configuration with **w$**in the input buffer and the start symbol S of G on top of the stack,above $The program in Fig.4.20 uses the predictive parsing table M to produce a predictive parse for the input.

![image-20240423014229705](./assets/image-20240423014229705-1713972744414-19.png)

注意产生式右部压栈的时候，最开始的在栈顶（即Y1在栈顶），每次循环判断栈顶是否与输入buffer中当前所指的终结符匹配，匹配则弹栈，输入后移，栈中存放待处理的元素

## NFA->DFA

### subsetConstruction


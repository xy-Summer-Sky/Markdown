# [思维导图框架](./思维导图/编译原理.xmind)

![编译原理](./assets/编译原理.png)

## 思维导图文本描述--编译原理

### 概述

#### 语言处理器

- 编译器

  进行翻译工作

  - 词法分析

    词法分析器读入组成源程序的字符流，并且将他们组织成有意义的词素序列，对于每个词素（lexeme），词法分析器产生词法单元（token）输出

  - 语法分析

    由产生的词法单元生成语法树

  - 语义分析

    使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致，同时收集类型信息，并把信息存放在语法树或符号表中。

  - 中间代码生成

    把源程序翻译成目标代码，一个便难以企可能会构造出一个或多个中间表示

  - 机器无关代码优化

  - 代码生成

    输入中间表示形式，映射到目标语言

  - 机器相关代码优化

- 解释器

  直接执行语句

### 词法分析

#### 作用

读入源程序字符流、组成词素，输出词法单元序列。
过滤空白、换行、制表符、注释等。
将词素添加到符号表中。
实现时通常和语法分析器处于同一趟中。

#### 名词解释

- 词法单元

  <词法单元名、属性值（可选）>
  词法单元名说明词法单位的类型，当该类型词法单元实例不唯一时，使用属性值进一步加以区分。语法分析器通过词法单元名即可确定词法单元序列的结构。

- 模式

  描述了一个词法单元的词素可能具有的形式
  关键词的模式就是组成该关键字的字符序列

- 词素

  源程序中跟某个词法单元模式相匹配的字符序列
  被词法分析器识别为该词法单元的一个实例

#### 词法单元的归约

- 串和语言

  - 字母表

    - 有限的符号集合

  - 串

    - 定义

      买某个字母表上的一个串是该字母表中符号的一个有穷序列。串的长度通常被记为s。

      长度为0的串被称为空串，记为ε

    - 串的计算

      - 串的前缀

        从尾部删除0个或多个符号后得到的串

      - 串的后缀

        从头部删除0个或多个符号后得到的串

      - 串的子串

        删除某个前缀和某个后缀后得到的串

      - 串的真前缀、真后缀、真子串

        既不等于ε，也不等于前缀、后缀、子串本身

      - 串的子序列

        从s中删除0个或多个符号后得到的串，符号不必相邻

      - 串的连接

        x=dog  y=cat
        xy=dogcat

      - 串的乘积

        s¹=s    
        s²=ss   
        s³=sss

  - 语言

    - 定义

      语言式某个给定字母表上任意可数的串集合

    - 语言的运算

      - L和M的并

      - L和M的连接

      - L和M的Kleene闭包

      - L的正闭包

        不包括Lº，也就是说如果L中不包含ε时，L的正闭包必不包含ε

- [正则表达式](https://blog.csdn.net/qq_40294512/article/details/89003655)

  - 定义

    用于描述一种语言。例如用letter代表任意字母，digit代表数位等
    正则表达式可以由较小的正则表达式按照规则递归构建，每个正则表达式r表示一个语言L(r)，其中有如下规则：
    ε是一个正则表达式，L(ε)={ε}，即改语言只包含空串
    如果a是Σ上的一个符号，那么a是一个正则表达式，并且L(a) = {a}

  - 运算

    (r) | (s)是一个正则表达式，表示语言L(r) ∪ L(s)

    (r) (s)是一个正则表达式，表示语言L(r) L(s)

    (r)*是一个正则表达式，表示语言L(r)*

    (r)是一个正则表达式，表示语言L(r)

    - 或

      交换律、结合律

    - 连接

      交换律、分配律

    - 闭包

      闭包中一定包含ε、幂等性

  - 拓展

    一个或多个实例r+
    零个或一个实例r？

- 词法单元的识别

  - 状态转换图

    - 状态

      - 开始状态

      - 接收状态

      - 普通状态

    - 边

- 有穷自动机

  是一种识别器，对输入的串回答yes or no，分为两类，这两种自动机是别的语言集合相同，都是正则语言。

  - [不确定的有穷自动机（NFA）](https://blog.csdn.net/qq_40294512/article/details/89004777)

    - 定义

      对其边上的标号没有限制，一个符号标记离开同一状态多条边，并且空串也可以作为标号

    - 组成

      五元组 M=(S, Σ, aδ, S0, F)

      - 有穷状态集合S

      - 输入符号集合Σ

      - 转换函数

      - 开始状态

      - 接收状态集合

  - [确定的有穷自动机（DFA）](https://blog.csdn.net/qq_40294512/article/details/89004777)

    - 定义

      对于每个状态及自动机输入字母表中的每个符号，有且只有一条离开该状态，以改符号为标号的边

    - 组成

  - [最简DFA](https://blog.csdn.net/qq_40294512/article/details/89004777)

### 语法分析

#### 作用

语法分析器从词法分析器获得一个由词法单元组成的串，并验证这个串可以由源语言的文法生成。

#### 分类

- 通用型（低效、不使用）

- 自顶向下

  代表文法：LL文法

- 自底向上

  代表文法：LR文法

#### 程序错误

- 词法错误

- 语法错误

- 语义错误

- 逻辑错误

#### 语法错误的处理

- 恐慌模式的恢复

  一旦发现错误就不断丢弃输入中的符号，一次丢弃一个，直到找到同步词法单元集合中的元素为止。

- 短语层次的恢复

  在余下的输入上进行局部性纠正

- 错误产生式

- 全局纠错

#### 上下文无关文法

- 定义

  - 终结符号

    终结符号是组成串的基本符号。例如特殊符号等等

  - 非终结符号

    非终结符号是组成串的集合的语法变量。非终结符号给出了语言的层次结构

  - 开始符号

    开始符号表示的串集合就是这个文法的生成语言。

  - 一组产生式

    描述了将终结符号和非终结符号组合成串的方法。每个产生式由以下几个元素构成：
    一个被称为产生式头/左部的非终结符号
    符号->
    一个由零个或多个终结符或非终结符组成的产生式体/右部

- [推导](https://blog.csdn.net/qq_40294512/article/details/89363560)

  从开始符号出发，每个重写步骤把一个非终结符替换为它的某个产生式体

  - 最左推导

  - 最右推导

- 句子/句型/语言

  如果S=>a，其中S是文法G的开始符号，我们就说a是G的一个句型。

  句子是不包含非终结符号的句型。

  语言式一个文法所有句子的集合。

- 二义性

  - 定义

    如果一个文法可以为某个句子生成多个语法分析树，那么就说他是二义性的。

  - 产生原因：就近匹配原则

- 每个正则语言都是一个上下文无关语言，反之不成立

- 消除左递归

- 提取左公因子

#### [自顶向下的语法分析](https://blog.csdn.net/qq_40294512/article/details/89397905)

- 定义

  自顶向下的语法分析可以被看做是为输入串构造语法分析树的问题
  也可以被看做是寻找输入串的最左推导的问题

- 方法:递归下降的语法分析

- 工具

  - FIRST集合

  - FOLLOW集合

- LL（1）文法

  从左向右扫描输入，产生最左推导，每步只需要向前看一个输入符号的语法分析动作

  - 条件

    不存在终结符号a使得α和β都能够推导出以a开头的串
    α和β中最多有一个可以推导出空串
    如果β=》ε，那么α不能推导出任何以FOLLOW（A）中某个终结符号开头的串。

  - 流程

    处理左递归
    提取左公因子
    求FIRST和FOLLOW集合
    构建预测分析表

#### 自底向上的语法分析

- 框架：移入-归约

- [移入归约分析技术](https://blog.csdn.net/qq_40294512/article/details/92621101)

  使用一个栈来保存文法符号，并使用一个缓冲区来存放需要进行语法分析的其他符号。

  - 动作

    - 移入

    - 归约

    - 接受

    - 报错

  - 冲突

    - 移入/归约冲突

      存在移入动作。归约动作的判断问题

    - 归约/归约冲突

      存在多个归约动作

- LR技术

  从左向右扫描，最右推导序列的技术

  - 表格驱动

  - 无回溯移入-归约技术

- [LR（0）自动机](https://www.jianshu.com/p/bf8d63791f57)

  - 项

    - 归约项目

    - 接收项目

    - 移进项目

    - 待约项目

  - 一个文法：增广文法

  - 两个函数：CLOSURE 和 GOTO

- [SLR语法分析表](https://blog.csdn.net/qq_40294512/article/details/92621351)

- LR（1）项集

- LALR方法

### 重点算法

#### 词法分析

- 正则生成NFA

- NFA转DFA

- DFA简化

#### 语法分析

- 消除左递归

- 提取左公因子

- FIRST集合和FOLLOW集合

- LL（1）预测分析表构建



# 作业以及课程笔记归纳

## 词法分析

### 词法分析--regx->DFA（汤姆逊构造法-子集构造法-最小化算法）

#### 步骤1: 汤姆逊构造法构建NFA

对于正则表达式 `a|ε`，我们分别为 `a` 和 `ε` 构建NFA，然后合并。

1. **构造 `a` 的NFA**：

   - 创建两个状态：`q0` 和 `q1`。
   - 添加从 `q0` 到 `q1` 的转移，标记为 `a`。

   图示如下：

   ```
   q0 --a--> q1
   ```

2. **构造 `ε` 的NFA**：

   - 创建两个状态 `q2` 和 `q3`。
   - 添加从 `q2` 到 `q3` 的ε转移。

   图示如下：

   ```
   q2 --ε--> q3
   ```

3. **合并 `a` 和 `ε` 的NFA**：

   - 创建一个新的起始状态 `q_start` 和一个新的接受状态 `q_accept`。
   - 添加从 `q_start` 到 `q0` 和 `q2` 的ε转移。
   - 添加从 `q1` 和 `q3` 到 `q_accept` 的ε转移。

   最终的NFA图示如下：

   ```
   q_start --ε--> q0 --a--> q1 --ε--> q_accept
             \                          ^
              \--ε--> q2 --ε--> q3 --ε-/
   ```

#### 步骤2: 子集构造法将NFA转换为DFA

现在我们使用子集构造法将上述NFA转换为DFA。

1. **初始状态**：

   - DFA的起始状态是NFA起始状态通过ε移动可达的所有状态的集合：`{q_start, q0, q2, q3, q_accept}`。

2. **计算转移**：

   - 从状态 `{q_start, q0, q2, q3, q_accept}` 输入 `a`：
     - 只有 `q0` 有标记为 `a` 的出边，它通向 `q1`。从 `q1` 可以通过ε到达 `q_accept`。因此，新的状态是 `{q1, q_accept}`。

3. **终止状态**：

   - 任何包含 `q_accept` 的状态都是DFA的接受状态。

   最终DFA的状态和转移如下：

   - 状态 `{q_start, q0, q2, q3, q_accept}`，标记为接受状态。
   - 状态 `{q1, q_accept}`，标记为接受状态。
   - 转移：`{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}`。

DFA 图示：

```
{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}
{q_start, q0, q2, q3, q_accept} ------------------- (为接受状态)
{q1, q_accept} ------------------- (为接受状态)
```

通过这一过程，我们已经从正则表达式 `a|ε` 构造出了DFA，该DFA有效地识别由 `a` 或空串 `ε` 组成的语言。

继续从上述的DFA最小化过程，我们将使用常见的状态最小化技术，通常包括初始划分（区分接受状态和非接受状态）并迭代地细化状态分区直到达到稳定状态。这一过程旨在合并所有行为相同的状态，从而简化DFA。

#### 步骤3: 状态最小化

由于在构造的DFA中，所有状态都是接受状态，这通常意味着每个状态在语言接受方面的行为都相同。但是，我们需要仔细检查这些状态对于所有输入符号的反应是否确实相同。

1. **初始状态划分**：
   - 由于 `{q_start, q0, q2, q3, q_accept}` 和 `{q1, q_accept}` 都是接受状态，我们可以开始考虑它们是否能够被进一步合并。这取决于它们对输入符号 `a` 的反应是否相同。

2. **检查转移**：
   - 从 `{q_start, q0, q2, q3, q_accept}` 输入 `a`，结果状态是 `{q1, q_accept}`。
   - 从 `{q1, q_accept}` 输入 `a` 时，由于没有定义从 `q1` 出发的 `a` 转移，这可以被视为一个死状态或沉默状态。这意味着这两个状态集在响应 `a` 时行为不同。

3. **无法进一步合并**：
   - 因为在接受字符 `a` 时，两个状态集的行为不同（一个转移到另一个，另一个无响应），我们无法将这两个状态合并。

4. **最终最小化DFA**：
   - 最小化后的DFA与前面生成的DFA相同，因为没有进一步的合并机会。

##### 最小化DFA的示意图和描述：

```
{q_start, q0, q2, q3, q_accept} --a--> {q1, q_accept}
{q_start, q0, q2, q3, q_accept} ------------------- (为接受状态)
{q1, q_accept} ------------------- (为接受状态)
```

- **状态**：
  - `{q_start, q0, q2, q3, q_accept}`：在没有输入时即可接受输入串（因为包含起始状态和接受状态）。
  - `{q1, q_accept}`：仅在接受字符 `a` 后接受输入串。



## 语法分析

### chapter 2 exercise p232

![image-20240421235036823](./assets/image-20240421235036823-1713972744412-1.png)

Textbook p206 exercise 4.2.2 d) 

(1)   Give a LM derivation, a RM derivation and a parser tree for the string; Justify whether the grammar is ambiguous or not

(2)   left factor and eliminate left recursion the grammar

(3)   Justify whether the rewritten grammar is LL(1) grammar or not.

(4)   construct LL(1) parsing table and analyze the string.



Every construct that can be described by a regular expression can be described by a grammar,but not vice-versa.Alternatively,every regular language is a context-free language,but not vice-versa.上下文无关文法>正则表达式

### Ambiguity



a grammar that produces more than one parse tree for some sentence is said to be ambiguous.Put another way,an ambiguous grammar is one that produces more than one leftmost derivation or more than one rightmost derivation for the same sentence

有多个解析树，或者有多于一个最左推导或者最有推导，即这个语法有歧义（如果没有歧义，左右推导得出的语法树相同，且验证需要多个句子列举测试）

### 句子和句型、句柄、活前缀

#### 句子（Sentence）

句子是特殊类型的句型，它不包含任何非终结符，只由终结符组成。句子是文法生成的最终产品，

#### 句型（Sentential Form）

句型是指从文法的起始符号（通常是非终结符）出发，通过一系列的产生式规则替换（应用文法中的规则），得到的一个由终结符和/或非终结符组成的字符串。句型代表了生成某个特定句子的过程中的一个中间状态，这个状态可能还包含一些非终结符（即还可以继续进行产生式规则的替换）。

句子只能由终结符，句型还可以有非终结符（可以是起始符号），句子为特殊的句型

#### 短语phrase

一个短语就是可以被规约为一个非终结符的串（可以是多部归约）

如果是一步规约，就是**简单短语**

#### handle

Formally: a **handle** of a **right-sentential form** γ is a production A → β and a position in γ where β may be found and replaced by A to produce the previous right-sentential form in a rightmost derivation of γ. i.e., if S ⇒∗rm αAw ⇒rm αβw then **A → β** in the position following α is a handle of αβw

Because γ is a right-sentential form, the substring to the **right of a handle** contains **only terminal symbols.**

最左简单短语是句柄，与上述定义不冲突

#### viable prefix（（规范）可行/活前缀）

出现在bottom up**解析栈中的即为可行前缀**，即**空串**代表初始状态也是一个可行前缀

规范前缀: 一个规范句型的一个前缀称为规范前缀, 如果该前缀后面的符号串不包含非终极符

![image-20240502142050694](./assets/image-20240502142050694.png)

- 规范前缀不包含简单短语;
- 或者该规范前缀只包含一个简单短语,而且是在该规范前缀的最后(这个简单短语就是句柄); 

换句话说，**规范活前缀不含句柄之后的任何符号**

![image-20240502142112949](./assets/image-20240502142112949.png)

分类：

- 非归态(移入)活前缀：规范活前缀不包含简单短语, 而且是在该规范活前缀的最后句柄尚未形成，需要继续移进若干符号后才能形成句柄
- 归态活前缀：只包含一个简单短语, 尾部正好是句柄之尾，此时可以进行规约。规约后又成为另一句型的活前缀
- ![image-20240502142404255](./assets/image-20240502142404255.png)

### Elimination of Left Recursion

general case：

First,group the productions as

![image-20240422204256911](./assets/image-20240422204256911-1713972744412-2.png)

where no βi begins with an A.Then,replace the A-productions by

![image-20240422204555296](./assets/image-20240422204555296-1713972744413-3.png)

但是上述算法解决不了涉及>=2个左递归的情况 it does not eliminate left recursion involving derivations of two or more steps：

for example：    ![image-20240422205149537](./assets/image-20240422205149537-1713972744413-4.png)

![image-20240422205203735](./assets/image-20240422205203735-1713972744413-5.png)

### Left Factoring

When the choice between two alternative A-productions is not clear,we may be able to rewrite the productions to defer the decision until enough of the input has  been seen that we can make the right choice.![image-20240422202825002](./assets/image-20240422202825002-1713972744413-6.png)

![image-20240422202838630](./assets/image-20240422202838630-1713972744413-7.png)

### Recursive-descent

General recursive-descent may require backtracking;that is,it may require repeated scans over the input.一般的递归下降需要回溯，即重复扫描输入

#### LL（1）grammer

###### first set

![image-20240422212811433](./assets/image-20240422212811433-1713972744413-8.png)

如果ε在FIRST(α)中，这表明存在至少一种从α开始的推导，使得α最终推导为一个空字符串。

###### follow set

![image-20240422212948228](./assets/image-20240422212948228-1713972744413-9.png)

![image-20240422235906689](./assets/image-20240422235906689-1713972744413-10.png)

这里切记**左边是右边的子集**

第一步中，**$**加入到起始非终结符的followset集合中

followset只针对于**非终结**符号

###### kookhead sets

![image-20240422213227334](./assets/image-20240422213227334-1713972744413-11.png)

Predictive parsers,that is,**recursive-descent** parsers needing no backtracking, can be constructed for a class of grammars called **LL(1)**.

- The first "L"in LL(1)stands for scanning the input from left to right从左到右扫描输入
- the second "L"for producinga leftmost derivation,最左推导的产生式
-  the "1"for using one input symbol of lookahead at each step to make parsing action decisions.

老师ppt对**LL(1)前提**的简化版，易于理解
A grammar is LL(1)grammar if the following conditions are satisfied:
![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

##### LL(1)文法的识别/判断-4部

1. 求出可空非终止符的集合（nullable nonterminal）

   

2. ![](./assets/image-20240422222743225-1713972744413-13.png)

3. ![image-20240422214233812](./assets/image-20240422214233812-1713972744413-15.png)

4. ![image-20240422214254730](./assets/image-20240422214254730-1713972744413-14.png)

example：![image-20240422225008300](./assets/image-20240422225008300-1713972744413-16.png)

只需要知道每个非终结符的first、follow的set以及可空非终结符（求first要用），其余的可以借助规则迅速推导，结合以下条件判断即可

![image-20240422213415664](./assets/image-20240422213415664-1713972744413-12.png)

一定不是LL(1)的情况：有左递归或者左公因子之一，一定不是LL(1）;但是二者皆没有不能保证一定是LL（1）文法

### construction of Predictive parsing table 

![image-20240423010552238](./assets/image-20240423010552238-1713972744413-18.png)

### Model of a table-driven predictive parser

![image-20240423013933306](./assets/image-20240423013933306-1713972744413-17.png)

栈中最开始存放start symbol，input buffer存放输入，$代表栈底或者输入结束

METHOD:Initially,the parser is in a configuration with **w$**in the input buffer and the start symbol S of G on top of the stack,above $The program in Fig.4.20 uses the predictive parsing table M to produce a predictive parse for the input.

![image-20240423014229705](./assets/image-20240423014229705-1713972744414-19.png)

注意产生式右部压栈的时候，最开始的在栈顶（即Y1在栈顶），每次循环判断栈顶是否与输入buffer中当前所指的终结符匹配，匹配则弹栈，输入后移，栈中存放待处理的元素

### Bottom-Up Parsing

#### LR（0）

每个规范集合确实可以被看作是一个状态

![image-20240427151736505](./assets/image-20240427151736505.png)

在LR(0)分析器中，决定是执行规约（reduction）操作还是移进（shift）操作，完全依赖于当前的栈顶状态和即将处理的输入符号。栈顶状态含有一组LR(0)项，这些项指导解析器如何响应输入符号。下面是如何根据栈顶状态来决定采取何种操作的过程：

##### 栈顶状态和解析决策

1. **查看栈顶状态**：
   - 每个状态是一组LR(0)项的集合，其中每一项都是一个产生式规则，带有一个“点”表示当前解析的进度。

2. **分析栈顶状态中的项**：
   - 如果点后面有符号（即点不在末尾），这意味着解析器在这个状态下期待看到某个特定的输入符号。
   - 如果点在末尾，这意味着对应的产生式可以进行规约。

3. **决定操作**：
   - **移进操作（Shift）**：如果栈顶状态中存在形如 `A -> α.Xβ` 的项，且当前的输入符号是 `X`，那么解析器将执行移进操作。解析器将输入符号 `X` 和转移到的新状态压入栈中。
   - **规约操作（Reduction）**：如果栈顶状态中存在形如 `A -> α.` 的项（点在末尾），无论当前输入符号是什么，解析器都将执行规约操作。规约时，根据产生式 `A -> α`，将栈顶的若干状态（与产生式右侧 `α` 的长度相等）弹出栈，然后把产生式左侧的非终结符 `A` 压入栈中。接着，解析器查看新的栈顶状态和非终结符 `A` 对应的转移，将转移后的状态压入栈中。

##### 示例

假设栈顶状态包含以下项：
- `S -> .AB`
- `A -> a.`
- `B -> b.`

并假设当前输入符号是 `a`：
- 因为存在项 `A -> a.` 且点在末尾，根据这个产生式进行规约操作，把 `a` 规约为非终结符 `A`。
- 如果输入符号是 `b`，且存在项 `B -> .b`，则进行移进操作。

##### 注意
实际的LR(0)解析器还需要一个分析表（parsing table），其中包含了对于每个状态和输入符号组合应采取的动作（移进、规约、接受或错误）。这个表是根据所有状态和所有输入符号预先计算和填充的。

##### 移进-规约冲突的发生条件

移进-规约冲突发生在以下情况下：

1. **移进冲突**：当前状态的一个项形如 `A -> α.Xβ`，其中 `X` 是当前的输入符号，这意味着根据当前的输入符号，解析器可能会选择执行移进操作。
2. **规约冲突**：同一状态还有另一个项形如 `B -> γ.`，点在末尾，这意味着可以根据这个产生式规约，无论当前的输入符号是什么。

当这两种情形在同一状态中同时出现时，解析器无法仅凭当前信息决定是应该移进还是规约，因此产生冲突。

#### 4.5.2 SLR

##### LR（0）存在的问题

移进-规约冲突发生在以下情况下：

1. **移进冲突**：当前状态的一个项形如 `A -> α.Xβ`，其中 `X` 是当前的输入符号，这意味着根据当前的输入符号，解析器可能会选择执行移进操作。
2. **规约冲突**：同一状态还有另一个项形如 `B -> γ.`，点在末尾，这意味着可以根据这个产生式规约，无论当前的输入符号是什么。

当这两种情形在同一状态中同时出现时，LR（0）解析器无法仅凭当前信息决定是应该移进还是规约，因此产生冲突。

使用LR（0）的状态集即可

The SLR method begins with LR(0)items and LR(O)automata；

That is,given a grammar,G,we augment G to produce G'with a new start symbol S'.From G',we construct C,the canonical collection
of sets of items for G'together with the GOTO function增广文法->规范集合

当LR（0）遇到既可规约也可以shift的情况的时候，由于无法判断上下文情况，它不知道当如果规约，当前的是否为句柄，即

##### slr基本思想

![image-20240427163028446](./assets/image-20240427163028446.png)

##### [SLR（1）分析表构建](https://www.jianshu.com/p/ad8af79e49b5)

语法分析表由两部分组成，一个语法分析**动作函数ACTION**和一个**转换函数GOTO**

1. ACTION函数有两个参数：一个是状态i,另一个是终结符号a(或是输入标记符号$)，ACTION[i,a]有四种形式

   - 移入j，j是一个状态
   - 归约A->β
   - 接受
   - 报错

2. 我们把定义在项集上的GOTO函数拓展为定义在状态集上的函数：如果**GOTO[Ii，A]=Ij**,那
   么GOTO也把状态i和一个非终结符号A映射到状态j。

3. 构建表示，我们约定：

   1. si表示移入并将状态压栈
   2. rj表示按照编号j的产生式归约
   3. acc表示接受
   4. 空白表示报错

4. 示例文法

   E ——> E + T | T
   T ——> T * F | F
   F ——> ( E ) | **id**

   ![image-20240502131705770](./assets/image-20240502131705770.png)

   ![image-20240502131728781](./assets/image-20240502131728781.png)

##### [SLR分析器（过程）](https://www.cnblogs.com/aishanyishi/p/10305031.html)

普通的shift、reduce 才会是一个STACK（没有引入ITEM状态），只是不断shifit直到能够reduce，reduce到不能reduce再继续shift；

分为四列：状态栈、符号栈、输入、action

1. 状态栈、符号栈不作为action判断依据，action取决于**状态栈顶和input最左部分**在解析表中对应的action表项；
2. GOTO用于规约后添加新状态到状态站栈中，判断依据为reduce使用的产生式的左部以及去除R（为reduce产生式右部长度）个状态后的状态栈的顶部

- LR分析器由三个部分组成：
- 其中:SP为栈指针，S[i]为状态栈，X[i]为文法符号栈。状态转换表用GOTO[i，X]=j表示，规定当栈顶状态为i，遇到当前文法符号为X时应转向状态j，X为终结符或非终结符。
- ACTION[i，a]规定了栈顶状态为i时遇到输入符号a应执行。动作有四种可能：

(1)移进：

action[i，a]= Sj：状态j移入到状态栈，把a移入到文法符号栈，其中i,j表示状态号。

(2)**归约**：

action[i，a]=rk：当在栈顶形成句柄时，则归约为相应的非终结符A，即文法中有A- B的产生式，若**B的长度为R**(即|B|=R)，则从**状态栈和文法符号栈中自顶向下去掉R个符号**，即栈指针SP减去R，并把A移入文法符号栈内，j=GOTO[i,A]移进状态栈，其中**i为修改指针后的栈顶状态**。

(3)接受acc:

当归约到文法符号栈中只剩文法的开始符号S时，并且输入符号串已结束即当前输入符是'$'，则为分析成功。

(4)报错:

当遇到状态栈顶为某一状态下出现不该遇到的文法符号时，则报错，说明输入端不是该文法能接受的符号串。

#### LR（1）

##### SLR存在的问题

SLR只是简单地考察下一个输入符号b是否属于与归约项目A→a相关联的FOLLOW(A),但b∈FOLLOW(A)只是归约的一个**必要条件**，而**非充分条件**

##### LR（1）提出

对于产生式
$$
A→\alpha
$$
的归约，在不同使用位置，会要求不同的后继符号,在特定位置，A的后继符集合是**FOLLOW(A)的子集**;SLR仅仅判断是否是在FOLLOW中，扩大了规约条件的范围；也导致SLR会出现归约和移进的冲突

![image-20240430180503939](./assets/image-20240430180503939.png)

将一般形式为A→aB,a的项称为LR(1)项，其中![image-20240430180900625](./assets/image-20240430180900625.png)是
一个产生式，**a**是一个**终结符**（这里将$视为一个特殊的终结符）它表示在当前状态下，A后面必须紧跟终结符，称为该项的**展望符(lookahead)**

1. LR(1)中的1指的是项的第二个分量的长度,形如![image-20240430181001587](./assets/image-20240430181001587.png)项中，展望符a没有任何作用
2. 但是一个形如![image-20240430181025038](./assets/image-20240430181025038.png)的项在只有在**下一个输入符号等于a**时才可以按照![image-20240430181102813](./assets/image-20240430181102813.png)进行归约
3. 这样的a的集合总是FOLLOW(A)的子集，而且它通常是一个真子集



##### LR(1)自动机

规范集合构建,不再依靠宽泛的识别下一个输入，而是利用![image-20240430205622718](./assets/image-20240430205622718.png)

![image-20240430205402182](./assets/image-20240430205402182.png)

细化状态，状态增多：解决方案-

如果除展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目是同心的，然后就可以在LALR中进行合并-只要项目的第一个分量相同就可以进行合并

##### LR（1）分析表构造算法

![image-20240430211812207](./assets/image-20240430211812207.png)

##### 总结

![image-20240430211157932](./assets/image-20240430211157932.png)

![image-20240430211225952](./assets/image-20240430211225952.png)’![image-20240430211324516](./assets/image-20240430211324516.png)

#### LALR

LR(1)对LR(0)进行分裂，状态增多，太多

##### LALR(lookahead-LR)分析的基本思想

1. 寻找具有相同核心（行为不冲突）的LR(1)项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合
2. 然后根据合并后得到的项集族构造语法分析表
3. 如果分析表中没有语法分析动作冲突，给定的文
   法就称为LALR(1)文法，就可以根据该分析表
   进行语法分析

如果除展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目是同心的，然后就可以在LALR中进行合并-只要项目的第一个分量相同就可以进行合并，合为同一个状态

##### 归约-归约冲突

![image-20240501124739660](./assets/image-20240501124739660.png)



**状态6和9**合并后会产生归约冲突，由于合并时其实是合并展望符，其只在归约时起作用；即不会对移进产生影响，那么**不会产生移进-归约**冲突（前提是合并前确保无冲突）

##### 推迟错误发现

![image-20240501125300262](./assets/image-20240501125300262.png)

![image-20240501130034110](./assets/image-20240501130034110.png)

例如输入如上图所示内容，由正则表达式可得，这个式子显然是错误的；在没有合并时，I4会直接报错；但是合并同心项目集I4、I9后，会进行归约操作，露出状态一（I0），进入到I2，然后才会报错

LALR分析法可能会作多余的归约动作，但绝不会作错误的移进操作

##### LALR(1)特点

- 形式上与LR(1)相同

- 大小上与LR(O)/SLR相当，合并同心，实际上就是LR（0）项目集

- 分析能力介于SLR和LR(1)二者之间

  SLR<LALR(1)<LR(1)

- 合并后的展望符集合仍为FOLLOW集的子集

#### 二义性文法

每个二义性文法都不是LR的
某些类型的二义性文法在语言的描述和实现中很有用，因为非二义性文法总是需要引入额外的非终结符号

>更简短、更自然

但是仍然可以进行LR分析，只是需要严格控制条件：

##### 二义性分析LR举例

1. 这里就是需要使用优先级和结合性的来解决冲突，例如状态7遇到输入+时，由于+是左结合，必须先处理栈内，则需要进行归约而不是移进；状态7遇到\*时，由于\*优先级高，则需要先移进，而不是归约栈内![image-20240501133905544](./assets/image-20240501133905544.png)

2. 就近原则消除歧义

   ![image-20240501134643372](./assets/image-20240501134643372.png)

   状态4遇到e时，既可reduce也可以shift，但是选择移进else,以便让它与前面的then（因为else的出现必须有if做为前置条件，而if then捆绑出现）配对

   ![image-20240501134706659](./assets/image-20240501134706659.png)

##### 二义性文法的使用

应该保守地使用二义性文法，并且必须在严格控制之下使用，因为稍有不慎就会导致语法分析器所识别的语言出现偏差

#### 语法错误恢复



## chapter5 Syntax-Directed  Translation 

## p328

